hello:
<unque char count (-1)> <string of unique chars (order used to encode data) (sorted low to high frequency)> <padding (0s then 1) (so data ends with file)> <encoded tree> <encoded data>
00000011                01100101 01101111 01101000 01100011                                                 0001                                                          00             0100011001
[      ]                [      ] [      ] [      ] [      ]                                                 [                                                                             ][      ]

hello -> 01101000 01100101 01101100 01101100 01101111 -> 00000011011001010110111101101000011000110001000100011001


hello world:
00000111 | 01100100 01110010 01110111 00100000 01100101 01101000 01101111 01101100 | 01 | 1 10 000 | 100 011 11 11 101 010 001 101 0001 11 0000
[      ]   [      ] [      ] [      ] [      ] [      ] [      ] [      ] [      ]   [           ]   [        ] [        ] [        ][        ]

hello world -> 0110100001100101011011000110110001101111001000000111011101101111011100100110110001100100 -> 0000011101100100011100100111011100100000011001010110100001101111011011000111000010001111111010100011010001110000

a:


a - 1

if there are 3 unique chracters or less, skip the tree encoding/decoding step (tree is already assumed to be 0)

when encoding
when decoding, if the first bit of the tree is 0, insert another 0 (1 -> 1, 0 -> 00, 01 -> 001)

samual thomas norman

a - 4
m - 3
s - 2
  - 2
o - 2
n - 2
u - 1
l - 1
t - 1
h - 1
r - 1

there are 11 unique characters -> 00001010

:::: om:::ltus:a:n:hr

2 / 2 - 1
3 / 4 - 10
3 / 6 - 010
1 / 6 - 000

00001010 | 01110010 01101000 01110100 01101100 01110101 01101110 01101111 00100000 01110011 01101101 01100001 | 0001 | 1 10 010 000 | 100 11 101 0011 11 0010 011 0001 00001 0101 101 11 100 011 0100 0101 00000 101 11 0100

00001010011100100110100001110100011011000111010101101110011011110010000001110011011011010110000100011100100001001110100111100100110001000010101101111000110100010100000101110100
0111001101100001011011010111010101100001011011000010000001110100011010000110111101101101011000010111001100100000011011100110111101110010011011010110000101101110

byte refers to length of input character, in most cases this is 8 bits

 1. create a bit stream to be output
 2. create a map of characters to character frequency
 3. write a byte containing the number of characters unique characters minus to output bit stream
 4. in order of lowest to highest frequency, write each unique character to output bit stream
 5. create a regular huffman tree from the frequency map
 6. in order, store the number of branches each layer (except the first) has
 7. create a temporary bit stream
 8. for each stored number...
     1. create a flat, left biased huffman tree with... end points
         a. if this is the first stored number, 2
         b. otherwise, the previous stored number times two
	 2. in order of left to right store the input mappings of the huffman tree
	 3. write the nth item of the input mappings corrosponding to the stored number to temporary bit stream
 9. generate a left biased tree from the stored numbers using that number to decide how many branches each layer should have
10. using the just generated huffman tree, write the encoded version of every character from input to the temporary bit stream
11. write 7 - the length of temporary bit stream modulo 8 number of 0s and then a 1 to the output bit stream
12. append the temporary bit stream to the output bit stream
13. return output bit
